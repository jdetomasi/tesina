\chapter{Análisis de requerimientos}
\label{cap:corpus}

El primer paso en la construcción de cualquier sistema de software, incluyendo los sistemas de generación de lenguaje natural, será el de realizar un análisis de requerimientos y a partir de ahí generar una especificación inicial del sistema. 

Para el análisis de requerimientos, seguiremos el enfoque propuesto por Reiter y Dale~\cite{reiter_dale} en el cual se propone realizar un \emph{corpus} de textos de ejemplo y a partir de ellos obtener una especificación para nuestro sistema.  

\section{Corpus de descripciones}                 

Este \emph{corpus de textos} constará de una colección de ejemplos, formados por la entrada y la salida esperada de nuestro sistema. En nuestro caso, la entrada de nuestro sistema será: la especificación formal en lenguaje Z, las designaciones y un grupo de clases de prueba generadas de antemano, mientras que la salida estará formada por las descripciones en lenguaje natural de las clases de prueba indicadas. En lo posible, el corpus de textos debe cubrir todo el rango de textos esperados a ser producidos por el sistema de generación de lenguaje natural; debería cubrir los casos más frecuentes, así como los casos mas inusuales que se puedan dar.

Para nuestro trabajo debemos recolectar un conjunto lo suficientemente amplio de ejemplos de clases de prueba que caractericen la variedad de textos que deseamos generar, luego una persona capacitada de leer lenguaje Z deberá describir en lenguaje natural las mismos. Finalmente se deberá revisar este \emph{corpus} inicial y modificarlo si existe algún caso en el que haya alguna descripción que resulte técnicamente imposible de generar o prohibitivamente cara a nivel computacional. Una vez finalizado este proceso tendremos en nuestro poder un \emph{corpus objetivo} que nos servirá para sustentar muchas de las decisiones que tomemos a lo largo del trabajo. Este también nos servirá para realizar una evaluación del sistema una vez implementado, comparando los textos generados por el nuestro sistema con las descripciones del \emph{corpus} realizadas por una persona.

Se pueden consultar los textos incluidos en el corpus utilizado para este trabajo en \emph{http://dcc.fceia.unr.edu.ar/$\sim$jdetomasi/nlg/corpus/}. Para elaborar el mismo recolectamos una serie de clases y casos de prueba generados con Fastest a partir de distintas especificaciones y luego se escribimos manualmente cada una de las descripciones de  estas clases de prueba. Con las especificaciones y clases de prueba incluidas en el \emph{corpus}, intentamos abarcar todo el rango de textos que esperamos que nuestro sistema sea capaz de producir, para esto tuvimos en cuenta incluir clases de pruebas que cubran todas las expresiones de Z contempladas dentro del alcance de este trabajo y sus posibles combinaciones. También trabajamos con especificaciones sobre distintos dominios de aplicación con el fin de lograr \emph{corpus} que nos sea de utilidad para dar con una solución que sea independiente del dominio de aplicación. En total trabajamos con clases de prueba generadas con \emph{fastest} para 10 especificaciones distintas; del total de clases de prueba correspondientes a estas especificaciones se escogieron las más significativas para describir y se ignoraron aquellas que contenían algún operador no considerado dentro del alcance de este trabajo.

La Figura~\ref{fig:ej_desc_lookup_sp_1} muestra a modo de ejemplo una descripción para la clase de prueba \emph{LookUp\_SP\_1} generada a partir de la especificación para una tabla de símbolos introducida anteriormente (pág.~\pageref{fig:spec_symbol_table}). 
El \emph{corpus de descripciones} utilizado para este trabajo, constará entonces de una colección de ejemplos como el anterior.


\begin{figure}[H]
  \centering
   \begin{schema}{LookUp\_ SP\_ 1}\\
  		LookUp\_ VIS 
  		\where
  	 	s? \in \dom st \\
 		\dom st = \{ s? \}
  	\end{schema}
  \caption{Clase de prueba para operación LookUp.}
  \label{fig:ej_lookup_sp_1}
\end{figure}

\begin{figure}[H]
Descripciones SymbolTable 

\bigskip
\textbf{LookUp\_SP\_1:} Se busca un símbolo en la tabla.  
  \begin{itemize}
   \item{Cuando:}
   \begin{itemize}
  	  \item{El símbolo a buscar pertenece a los símbolos cargados en la tabla de símbolos.}
  	  \item{El símbolo a buscar es el único elemento del conjunto formado por los símbolos cargados en la tabla de símbolos.}   
   \end{itemize}
  \end{itemize}
  \caption{Descripción en lenguaje natural para \emph{LookUp\_SP\_1}.}
  \label{fig:ej_desc_lookup_sp_1}
\end{figure}

\section{Análisis del corpus}
\label{sec:corpus_analisis}

Como mencionamos anteriormente muchas decisiones de diseño de nuestro sistema estarán fundamentados en observaciones obtenidas a partir del \emph{corpus}, a partir de éste podremos obtener una especie de especificación para nuestro trabajo.

Lo primero que podemos observar de los textos de ejemplo es la estructura del texto que se mantiene en la descripción de cada clase de prueba. En todas, se comenzará por el nombre de la clase de prueba, seguido por una pequeña descripción y luego una lista de oraciones, una por cada restricción de la clase de prueba que se está describiendo. Esto nos ayudará en el capítulo~\ref{cap:document_planning} para definir la estructura de nuestro documento. 

El desafío principal de nuestro sistema será el de describir en lenguaje natural las distintas expresiones Z que pueden aparecer en el cuerpo de los esquemas de una clase de prueba. En otras palabras, nuetro sistema deberá ser capaz de construir una oración en lenguaje natural a partir de una expresión Z y un conjunto de designaciones. 

Siguiendo con el análisis del \emph{corpus}, podemos notar, como era de esperarse, que los textos que surgen a partir de los operadores de Z se repiten (con pequeñas variantes que analizaremos mas adelante) independientemente del dominio de aplicación y las diferencias que aparecen se deben principalmente al texto incluido en las designaciones. Por ejemplo, consideremos las siguientes dos expresiones y sus respectivas descripciones en lenguaje natural, una pertenece al ejemplo antarior y la otra la otra es parte de una clase de prueba para la especificación de un sistema bancario:

\begin{itemize}
	\item $s? \in \dom$ $\rightarrow$ \emph{``El símbolo a buscar \textbf{pertenece a} los símbolos cargados en la tabla de símbolos.''}
	\item $s? \in \dom$ $\rightarrow$ \emph{``El número de cuenta \textbf{pertenece a} los números de cuenta cargados en el banco.''}
\end{itemize}

Como vemos, el texto \emph{``pertenece a''} aparece en abmas descripciones como resultado de verbalizar el operador $\in$ de Z y como mencionamos antes, se diferencia en el texto que antecede y precede al anterior en base a descripciones generadas a partir de las designaciones de cada sistema.

Intentaremos entonces idear un conjunto de reglas que nos permita especificar las descripciones que nuestro sistema deberá generar para cada operador de Z (y las combinaciones de los mismos) contemplado dentro del alcance de este trabajo. Llamaremos \emph{verb()} a la función encargada de \textbf{verbalizar} en lenguage natural una expresión Z a partir de la misma y las designaciones de la especificación en cuestión. En lo que queda de esta sección intentaremos dar con una especificación para la función recién mencionada introduciendo también, nuevos requerimientos para nuestro sistema.

Como antes mencionamos, nuestra función \emph{verb} tomará como entrada una expresión Z y devolverá una descripción en lenguaje natural para la misma. En primer instancia ésta debería verificar si la expresión se encuentra designada, de ser así el resultado deberá ser generado a partir de la designación. En caso de no estar designada la definición de \emph{verb} dependerá del conjunto de reglas antes mencionado.

Contemplemos primero la primer posibilidad, en la que \emph{verb} debe generar un texto en lenguaje natural a partir de una expresión que se encuentra designada. Acá tendremos que contemplar si se trata o no de una designación parametrizada. De no ser el caso, el resultado sería exactamente el texto de la designación. De lo contrario, habrá primero que verbalizar el parámetro de la designacion y luego construir el texto a partir del texto de la designacion parametrizada y la verbalización del parametro~\footnote{TODO: aclarar que suponemos que el parametro debe estar designado?}.

\begin{figure}[H]
\begin{algorithmic}
\Function {verb}{$exp$}
\If{$esta\_designada(exp)$}
\State $ret\gets \text{designacion}(exp)$
\State \ldots
\EndIf
\State \textbf{return} $ret$
\EndFunction
\Statex
\end{algorithmic}
\caption{Bosquejo verbalización.}
\end{figure}

En el ejemplo anterior podemos ver un bosquejo del primer caso que deberemos contemplar para verbalizar una expresión Z. En el mismo abstraemos mediante la función \emph{designacion} la verbalización de una exrpesión designada, que deberemos hacer teniendo encuenta las posibilidades antes mencionadas.

El otro caso en nuestra tarea de verbalización sería que tengamos que verbalizar una expresión no designada. Es en esta situación donde deberemos generar un texto que dependerá de la expresión en cuestión y como la misma se encuentra combinada con otras expresiones. Para esto, a partir de un análisis completo del corpus,  logramos abstraer un conjunto de reglas para la descripción de cada uno de los operadores de Z incluídos dentro del alcance del trabajo. Estas reglas resultarán indispensables para la tarea de \emph{lexicalización} que deberemos llevar a cabo. A continuación detallaremos el conjunto total de estas reglas, agrupadas por operador.

\bigskip
\begin{itemize} [label={$\triangleright$}, leftmargin=*]
\item{$=$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$\{exp1\} = exp2$}{\nlgfun{verb(exp1)} + \nlgtext{es el único elemento de} + \nlgfun{verb(exp2)}}
		\reglaverb{$exp1$ $=$ $\{\}$}{\nlgtext{no hay ningún elemento en}  + \nlgfun{verb(exp1)}}
		\reglaverb{$exp1 \cap exp2 = \{\}$}{\nlgfun{verb(exp1)} + \nlgtext{y} + \nlgfun{verb(exp2)} + \nlgtext{no tienen ningún elemento en común}}
		\reglaverb{$exp1 \cap \{exp2\} = \{\}$}{\nlgfun{verb(exp2)} + \nlgtext{no pertenece a} + \nlgfun{verb(exp1)}}
		\reglaverb{$exp1 = exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{es(son) igual(iguales) a} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\neq$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \neq \{\}$}{\nlgtext{existe al menos un elemento en} + \nlgfun{verb(exp1)}}
		\reglaverb{$exp1 \cap exp2 \neq \{\}$}{\nlgfun{verb(exp1)} + \nlgtext{y} + \nlgfun{verb(exp2)} + \nlgtext{tienen al menos un elemento en común}}
		\reglaverb{$exp1 \neq exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{no es(son) igual(iguales) a} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$<$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 < exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{es menor a} + \nlgfun{verb(exp2)}}
		\reglaverb{$exp1 < 0$}{\nlgfun{verb(exp1)} + \nlgtext{es negativo}}
	\end{enumerate}
\item{$\leq$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \leq exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{es menor o igual a} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$>$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 > exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{es mayor a} + \nlgfun{verb(exp2)}}
		\reglaverb{$exp1 > 0$}{\nlgfun{verb(exp1)} + \nlgtext{es positivo}}
	\end{enumerate}
\item{$\geq$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \geq exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{es mayor o igual a} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\in$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \in exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{pertenece(n) a} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\notin$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \notin exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{no pertenece(n) a} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\subset$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \subset exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{está(n) incluido/a(s) en} + \nlgfun{verb(exp2)}}
		\reglaverb{$\{exp1, exp2, \ldots , expn\} \subset expm$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{,} + \nlgfun{verb(exp2)} + \nlgtext{, \ldots , y} + \nlgfun{verb(expn)} + \nlgtext{pertenece(n) a} + \nlgfun{verb(expm)}}
		\end{enumerate}
\item{$\not\subset$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \not\subset exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{no está(n) incluido/a(s) en} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\subseteq$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \subseteq exp2$ (caso default)}{\nlgfun{verb(exp1)} + \nlgtext{está incluido o es igual a} + \nlgfun{verb(exp2)}}
		\reglaverb{$\{exp1, exp2, \ldots , expn\} \subseteq exp2$}{ídem inclusión}
	\end{enumerate}
\item{$\not\subseteq$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \not\subseteq exp2$ (caso default)}{\nlgtext{existe al menos un elemento en} + \nlgfun{verb(exp1)} + \nlgtext{que no se está en} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\mapsto$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \mapsto exp2$ (caso default)}{\nlgtext{el par ordenado formado por:} + \nlgfun{verb(exp1)} + \nlgtext{y} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\{a, b, \ldots\}$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$\{\}$}{\nlgtext{el conjunto vacío}}
		\reglaverb{$\{exp1\}$}{\nlgtext{el conjunto formado por } + \nlgfun{verb(exp1)}}
		\reglaverb{$\{exp1, exp2, \ldots ,expn\}$ (caso default)}{\nlgtext{el conjunto formado por} + \nlgfun{verb(exp1)} + \nlgtext{,} + \nlgfun{verb(exp2)} + \nlgtext{, \ldots , y} + \nlgfun{verb(expn)}}
	\end{enumerate}
\item{$\cup$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \cup exp2$ (caso default)}{\nlgtext{elementos en} + \nlgfun{verb(exp1)} + \nlgtext{y en} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$\cap$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$exp1 \cap exp2$ (caso default)}{\nlgtext{elementos en} + \nlgfun{verb(exp1)} + \nlgtext{que también se encuentren en} + \nlgfun{verb(exp2)}}
	\end{enumerate}
\item{$f~x$ (aplicación)}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$f~exp1$ (caso default)}{\nlgfun{verb(f)} + \nlgtext{aplicada a} + \nlgfun{verb(exp1)}}
	\end{enumerate}
\item{$dom$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$dom(exp1)$ (caso default)}{\nlgtext{dominio de} + \nlgfun{verb(exp1)}}
	\end{enumerate}
\item{$ran$}
	\begin{enumerate}	 
	\setlength{\itemsep}{7pt}
		\reglaverb{$ran(exp1)$ (caso default)}{\nlgtext{rango de} + \nlgfun{verb(exp1)}}
	\end{enumerate}
\end{itemize}  

Podemos obserbar que, en la mayoría de los casos, para resolver una expresión compuesta deberemos resolver recursivamente cada una de las partes para luego construir el texto final (pudiendo alguna de las partes estar designada).

Otro punto a tener en cuenta al momento de verbalizar una expresión será que las designaciones documentadas por el usuario pueden no contener un artículo que acompañe al sustantivo. En estos casos nuestro sistema deberá identificar los casos en los que sea necesario y agregar el artículo apropiado de forma que concuerde en genero y numero con el sustantivo. 

Finalmente, en base a las reglas introducidas anteriormente, podemos podemos observar que en su mayoría de las frases a generar se tratan de oraciones bimembres ordenadas como \emph{sujeto + verbo + objeto}. Todas expresadas en tiempo presente. Además, en algunos casos será necesario conjugar el verbo de una oración de forma tal que concuerde con el número del sujeto de la misma. Algo parecido pasa con el atributo en los casos que utilizamos un verbo copulativo en el que deberemos hacer concordar el mismo con numero y género del sujeto. Estas últimas observaciones deberemos tenerla en cuenta en el desarrollo de nuestro realizador lingüístico.
